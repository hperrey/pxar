################################################
#                 WARNING!                     #
# This file has been auto-generated by xdress. #
# Do not modify!!!                             #
#                                              #
#                                              #
#                    Come on, guys. I mean it! #
################################################
"""
"""
cimport api
cimport numpy as np
cimport xdress_extra_types
from libc.stdlib cimport free
from libcpp.map cimport map as cpp_map
from libcpp.string cimport string as std_string
from libcpp.utility cimport pair as cpp_pair
from libcpp.vector cimport vector as cpp_vector
from pyPxarCore cimport c_api

import numpy as np

np.import_array()



cdef class tbmConfig:
    """no docstring for tbmConfig, please file a bug report!"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults
        self._dacs = None

    def __init__(self):
        """tbmConfig(self)
        """
        self._inst = new c_api.tbmConfig()
    
    
    def __dealloc__(self):
        if self._free_inst:
            free(self._inst)

    # attributes
    property dacs:
        """no docstring for dacs, please file a bug report!"""
        def __get__(self):
            cdef stlcontainers._MapUCharUChar dacs_proxy
            if self._dacs is None:
                dacs_proxy = stlcontainers.MapUCharUChar(False, False)
                dacs_proxy.map_ptr = &(<c_api.tbmConfig *> self._inst).dacs
                self._dacs = dacs_proxy
            return self._dacs
    
        def __set__(self, value):
            cdef stlcontainers._MapUCharUChar value_proxy
            value_proxy = stlcontainers.MapUCharUChar(value, not isinstance(value, stlcontainers._MapUCharUChar))
            (<c_api.tbmConfig *> self._inst).dacs = value_proxy.map_ptr[0]
            self._dacs = None
    
    
    property enable:
        """no docstring for enable, please file a bug report!"""
        def __get__(self):
            return bool((<c_api.tbmConfig *> self._inst).enable)
    
        def __set__(self, value):
            (<c_api.tbmConfig *> self._inst).enable = <bint> value
    
    
    property type:
        """no docstring for type, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.tbmConfig *> self._inst).type)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.tbmConfig *> self._inst).type = (<unsigned char *> value_bytes)[0]
    
    
    # methods
    

    pass





cdef class pixelConfig:
    """no docstring for pixelConfig, please file a bug report!"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults


    def _pixelconfig_pixelconfig_0(self):
        """pixelConfig(self)
        """
        self._inst = new c_api.pixelConfig()
    
    
    def _pixelconfig_pixelconfig_1(self, _column, _row, _trim):
        """pixelConfig(self, _column, _row, _trim)
        """
        cdef unsigned char _column_proxy
        cdef unsigned char _row_proxy
        cdef unsigned char _trim_proxy
        _column_bytes = _column.encode()
        _row_bytes = _row.encode()
        _trim_bytes = _trim.encode()
        self._inst = new c_api.pixelConfig((<unsigned char *> _column_bytes)[0], (<unsigned char *> _row_bytes)[0], (<unsigned char *> _trim_bytes)[0])
    
    
    _pixelconfig_pixelconfig_0_argtypes = frozenset()
    _pixelconfig_pixelconfig_1_argtypes = frozenset(((0, str), (1, str), (2, str), ("_column", str), ("_row", str), ("_trim", str)))
    
    def __init__(self, *args, **kwargs):
        """pixelConfig(self, _column, _row, _trim)
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._pixelconfig_pixelconfig_0_argtypes:
            self._pixelconfig_pixelconfig_0(*args, **kwargs)
            return
        if types <= self._pixelconfig_pixelconfig_1_argtypes:
            self._pixelconfig_pixelconfig_1(*args, **kwargs)
            return
        # duck-typed dispatch based on whatever works!
        try:
            self._pixelconfig_pixelconfig_0(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._pixelconfig_pixelconfig_1(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method __init__() could not be dispatched')
    
    def __dealloc__(self):
        if self._free_inst:
            free(self._inst)

    # attributes
    property column:
        """no docstring for column, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.pixelConfig *> self._inst).column)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.pixelConfig *> self._inst).column = (<unsigned char *> value_bytes)[0]
    
    
    property enable:
        """no docstring for enable, please file a bug report!"""
        def __get__(self):
            return bool((<c_api.pixelConfig *> self._inst).enable)
    
        def __set__(self, value):
            (<c_api.pixelConfig *> self._inst).enable = <bint> value
    
    
    property mask:
        """no docstring for mask, please file a bug report!"""
        def __get__(self):
            return bool((<c_api.pixelConfig *> self._inst).mask)
    
        def __set__(self, value):
            (<c_api.pixelConfig *> self._inst).mask = <bint> value
    
    
    property row:
        """no docstring for row, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.pixelConfig *> self._inst).row)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.pixelConfig *> self._inst).row = (<unsigned char *> value_bytes)[0]
    
    
    property trim:
        """no docstring for trim, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.pixelConfig *> self._inst).trim)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.pixelConfig *> self._inst).trim = (<unsigned char *> value_bytes)[0]
    
    
    # methods
    

    pass





cdef class api:
    """no docstring for api, please file a bug report!"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults


    def __init__(self, usbId="*", logLevel="WARNING"):
        """api(self, usbId="*", logLevel="WARNING")
        """
        cdef char * usbId_proxy
        cdef char * logLevel_proxy
        usbId_bytes = usbId.encode()
        logLevel_bytes = logLevel.encode()
        self._inst = new c_api.api(std_string(<char *> usbId_bytes), std_string(<char *> logLevel_bytes))
    
    
    def __dealloc__(self):
        if self._free_inst:
            free(self._inst)

    # attributes

    # methods
    def HVoff(self):
        """HVoff(self)
        no docstring for HVoff, please file a bug report!"""
        (<c_api.api *> self._inst).HVoff()
    
    
    def HVon(self):
        """HVon(self)
        no docstring for HVon, please file a bug report!"""
        (<c_api.api *> self._inst).HVon()
    
    
    def Poff(self):
        """Poff(self)
        no docstring for Poff, please file a bug report!"""
        (<c_api.api *> self._inst).Poff()
    
    
    def Pon(self):
        """Pon(self)
        no docstring for Pon, please file a bug report!"""
        (<c_api.api *> self._inst).Pon()
    
    
    def SignalProbe(self, probe, name):
        """SignalProbe(self, probe, name)
        no docstring for SignalProbe, please file a bug report!"""
        cdef char * probe_proxy
        cdef char * name_proxy
        cdef bint rtnval
        probe_bytes = probe.encode()
        name_bytes = name.encode()
        rtnval = (<c_api.api *> self._inst).SignalProbe(std_string(<char *> probe_bytes), std_string(<char *> name_bytes))
        return bool(rtnval)
    
    
    def daqGetBuffer(self):
        """daqGetBuffer(self)
        no docstring for daqGetBuffer, please file a bug report!"""
        cdef cpp_vector[xdress_extra_types.uint16] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.api *> self._inst).daqGetBuffer()
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_UINT16, &rtnval[0])
        return rtnval_proxy
    
    
    def daqGetEvent(self):
        """daqGetEvent(self)
        no docstring for daqGetEvent, please file a bug report!"""
        cdef cpp_vector[c_api.pixel] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.api *> self._inst).daqGetEvent()
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_pixel.num, &rtnval[0])
        return rtnval_proxy
    
    
    def daqStart(self, pg_setup):
        """daqStart(self, pg_setup)
        no docstring for daqStart, please file a bug report!"""
        cdef cpp_vector[cpp_pair[xdress_extra_types.uint16, xdress_extra_types.uchar]] pg_setup_proxy
        cdef int ipg_setup
        cdef int pg_setup_size
        cdef void * pg_setup_data
        cdef bint rtnval
        # pg_setup is a ('vector', ('pair', 'uint16', 'uchar', 0), 0)
        pg_setup_size = len(pg_setup)
        if isinstance(pg_setup, np.ndarray) and (<np.ndarray> pg_setup).descr.type_num == np.NPY_OBJECT:
            pg_setup_data = <void *> np.PyArray_DATA(<np.ndarray> pg_setup)
            pg_setup_proxy = cpp_vector[cpp_pair[xdress_extra_types.uint16, xdress_extra_types.uchar]](<size_t> pg_setup_size)
            for ipg_setup in range(pg_setup_size):
                pg_setup_proxy[ipg_setup] = pg_setup_data[ipg_setup]
        else:
            pg_setup_proxy = cpp_vector[cpp_pair[xdress_extra_types.uint16, xdress_extra_types.uchar]](<size_t> pg_setup_size)
            for ipg_setup in range(pg_setup_size):
                pg_setup_proxy[ipg_setup] = <void> pg_setup[ipg_setup]
        rtnval = (<c_api.api *> self._inst).daqStart(pg_setup_proxy)
        return bool(rtnval)
    
    
    def daqStop(self):
        """daqStop(self)
        no docstring for daqStop, please file a bug report!"""
        cdef bint rtnval
        rtnval = (<c_api.api *> self._inst).daqStop()
        return bool(rtnval)
    
    
    def daqTrigger(self, nTrig=1):
        """daqTrigger(self, nTrig=1)
        no docstring for daqTrigger, please file a bug report!"""
        (<c_api.api *> self._inst).daqTrigger(<xdress_extra_types.uint32> long(nTrig))
    
    
    def daqTriggerLoop(self, period=1000):
        """daqTriggerLoop(self, period=1000)
        no docstring for daqTriggerLoop, please file a bug report!"""
        (<c_api.api *> self._inst).daqTriggerLoop(<unsigned short> period)
    
    
    def flashTB(self, filename):
        """flashTB(self, filename)
        no docstring for flashTB, please file a bug report!"""
        cdef char * filename_proxy
        cdef bint rtnval
        filename_bytes = filename.encode()
        rtnval = (<c_api.api *> self._inst).flashTB(std_string(<char *> filename_bytes))
        return bool(rtnval)
    
    
    def getEfficiencyMap(self, flags=0, nTriggers=16):
        """getEfficiencyMap(self, flags=0, nTriggers=16)
        no docstring for getEfficiencyMap, please file a bug report!"""
        cdef cpp_vector[c_api.pixel] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.api *> self._inst).getEfficiencyMap(<unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_pixel.num, &rtnval[0])
        return rtnval_proxy
    
    
    def getEfficiencyVsDAC(self, dacName, dacMin, dacMax, flags=0, nTriggers=16):
        """getEfficiencyVsDAC(self, dacName, dacMin, dacMax, flags=0, nTriggers=16)
        no docstring for getEfficiencyVsDAC, please file a bug report!"""
        cdef char * dacName_proxy
        cdef unsigned char dacMin_proxy
        cdef unsigned char dacMax_proxy
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, 0]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dacName_bytes = dacName.encode()
        dacMin_bytes = dacMin.encode()
        dacMax_bytes = dacMax.encode()
        rtnval = (<c_api.api *> self._inst).getEfficiencyVsDAC(std_string(<char *> dacName_bytes), (<unsigned char *> dacMin_bytes)[0], (<unsigned char *> dacMax_bytes)[0], <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getEfficiencyVsDACDAC(self, dac1name, dac1min, dac1max, dac2name, dac2min, dac2max, flags=0, nTriggers=16):
        """getEfficiencyVsDACDAC(self, dac1name, dac1min, dac1max, dac2name, dac2min, dac2max, flags=0, nTriggers=16)
        no docstring for getEfficiencyVsDACDAC, please file a bug report!"""
        cdef char * dac1name_proxy
        cdef unsigned char dac1min_proxy
        cdef unsigned char dac1max_proxy
        cdef char * dac2name_proxy
        cdef unsigned char dac2min_proxy
        cdef unsigned char dac2max_proxy
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, 0]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dac1name_bytes = dac1name.encode()
        dac1min_bytes = dac1min.encode()
        dac1max_bytes = dac1max.encode()
        dac2name_bytes = dac2name.encode()
        dac2min_bytes = dac2min.encode()
        dac2max_bytes = dac2max.encode()
        rtnval = (<c_api.api *> self._inst).getEfficiencyVsDACDAC(std_string(<char *> dac1name_bytes), (<unsigned char *> dac1min_bytes)[0], (<unsigned char *> dac1max_bytes)[0], std_string(<char *> dac2name_bytes), (<unsigned char *> dac2min_bytes)[0], (<unsigned char *> dac2max_bytes)[0], <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getPulseheightMap(self, flags=0, nTriggers=16):
        """getPulseheightMap(self, flags=0, nTriggers=16)
        no docstring for getPulseheightMap, please file a bug report!"""
        cdef cpp_vector[c_api.pixel] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.api *> self._inst).getPulseheightMap(<unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_pixel.num, &rtnval[0])
        return rtnval_proxy
    
    
    def getPulseheightVsDAC(self, dacName, dacMin, dacMax, flags=0, nTriggers=16):
        """getPulseheightVsDAC(self, dacName, dacMin, dacMax, flags=0, nTriggers=16)
        no docstring for getPulseheightVsDAC, please file a bug report!"""
        cdef char * dacName_proxy
        cdef unsigned char dacMin_proxy
        cdef unsigned char dacMax_proxy
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, 0]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dacName_bytes = dacName.encode()
        dacMin_bytes = dacMin.encode()
        dacMax_bytes = dacMax.encode()
        rtnval = (<c_api.api *> self._inst).getPulseheightVsDAC(std_string(<char *> dacName_bytes), (<unsigned char *> dacMin_bytes)[0], (<unsigned char *> dacMax_bytes)[0], <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getPulseheightVsDACDAC(self, dac1name, dac1min, dac1max, dac2name, dac2min, dac2max, flags=0, nTriggers=16):
        """getPulseheightVsDACDAC(self, dac1name, dac1min, dac1max, dac2name, dac2min, dac2max, flags=0, nTriggers=16)
        no docstring for getPulseheightVsDACDAC, please file a bug report!"""
        cdef char * dac1name_proxy
        cdef unsigned char dac1min_proxy
        cdef unsigned char dac1max_proxy
        cdef char * dac2name_proxy
        cdef unsigned char dac2min_proxy
        cdef unsigned char dac2max_proxy
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, 0]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dac1name_bytes = dac1name.encode()
        dac1min_bytes = dac1min.encode()
        dac1max_bytes = dac1max.encode()
        dac2name_bytes = dac2name.encode()
        dac2min_bytes = dac2min.encode()
        dac2max_bytes = dac2max.encode()
        rtnval = (<c_api.api *> self._inst).getPulseheightVsDACDAC(std_string(<char *> dac1name_bytes), (<unsigned char *> dac1min_bytes)[0], (<unsigned char *> dac1max_bytes)[0], std_string(<char *> dac2name_bytes), (<unsigned char *> dac2min_bytes)[0], (<unsigned char *> dac2max_bytes)[0], <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getReadbackValue(self, parameterName):
        """getReadbackValue(self, parameterName)
        no docstring for getReadbackValue, please file a bug report!"""
        cdef char * parameterName_proxy
        cdef int rtnval
        parameterName_bytes = parameterName.encode()
        rtnval = (<c_api.api *> self._inst).getReadbackValue(std_string(<char *> parameterName_bytes))
        return int(rtnval)
    
    
    def getTBia(self):
        """getTBia(self)
        no docstring for getTBia, please file a bug report!"""
        cdef double rtnval
        rtnval = (<c_api.api *> self._inst).getTBia()
        return float(rtnval)
    
    
    def getTBid(self):
        """getTBid(self)
        no docstring for getTBid, please file a bug report!"""
        cdef double rtnval
        rtnval = (<c_api.api *> self._inst).getTBid()
        return float(rtnval)
    
    
    def getTBva(self):
        """getTBva(self)
        no docstring for getTBva, please file a bug report!"""
        cdef double rtnval
        rtnval = (<c_api.api *> self._inst).getTBva()
        return float(rtnval)
    
    
    def getTBvd(self):
        """getTBvd(self)
        no docstring for getTBvd, please file a bug report!"""
        cdef double rtnval
        rtnval = (<c_api.api *> self._inst).getTBvd()
        return float(rtnval)
    
    
    def getThresholdMap(self, dacName, flags=0, nTriggers=16):
        """getThresholdMap(self, dacName, flags=0, nTriggers=16)
        no docstring for getThresholdMap, please file a bug report!"""
        cdef char * dacName_proxy
        cdef cpp_vector[c_api.pixel] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dacName_bytes = dacName.encode()
        rtnval = (<c_api.api *> self._inst).getThresholdMap(std_string(<char *> dacName_bytes), <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_pixel.num, &rtnval[0])
        return rtnval_proxy
    
    
    def getThresholdVsDAC(self, dacName, dacMin, dacMax, flags=0, nTriggers=16):
        """getThresholdVsDAC(self, dacName, dacMin, dacMax, flags=0, nTriggers=16)
        no docstring for getThresholdVsDAC, please file a bug report!"""
        cdef char * dacName_proxy
        cdef unsigned char dacMin_proxy
        cdef unsigned char dacMax_proxy
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, 0]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dacName_bytes = dacName.encode()
        dacMin_bytes = dacMin.encode()
        dacMax_bytes = dacMax.encode()
        rtnval = (<c_api.api *> self._inst).getThresholdVsDAC(std_string(<char *> dacName_bytes), (<unsigned char *> dacMin_bytes)[0], (<unsigned char *> dacMax_bytes)[0], <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getThresholdVsDACDAC(self, dac1name, dac1min, dac1max, dac2name, dac2min, dac2max, flags=0, nTriggers=16):
        """getThresholdVsDACDAC(self, dac1name, dac1min, dac1max, dac2name, dac2min, dac2max, flags=0, nTriggers=16)
        no docstring for getThresholdVsDACDAC, please file a bug report!"""
        cdef char * dac1name_proxy
        cdef unsigned char dac1min_proxy
        cdef unsigned char dac1max_proxy
        cdef char * dac2name_proxy
        cdef unsigned char dac2min_proxy
        cdef unsigned char dac2max_proxy
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, 0]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        dac1name_bytes = dac1name.encode()
        dac1min_bytes = dac1min.encode()
        dac1max_bytes = dac1max.encode()
        dac2name_bytes = dac2name.encode()
        dac2min_bytes = dac2min.encode()
        dac2max_bytes = dac2max.encode()
        rtnval = (<c_api.api *> self._inst).getThresholdVsDACDAC(std_string(<char *> dac1name_bytes), (<unsigned char *> dac1min_bytes)[0], (<unsigned char *> dac1max_bytes)[0], std_string(<char *> dac2name_bytes), (<unsigned char *> dac2min_bytes)[0], (<unsigned char *> dac2max_bytes)[0], <unsigned short> flags, <xdress_extra_types.uint32> long(nTriggers))
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getVersion(self):
        """getVersion(self)
        no docstring for getVersion, please file a bug report!"""
        cdef std_string rtnval
        rtnval = (<c_api.api *> self._inst).getVersion()
        return bytes(<char *> rtnval.c_str()).decode()
    
    
    def initDUT(self, tbmtype, tbmDACs, roctype, rocDACs, rocPixels):
        """initDUT(self, tbmtype, tbmDACs, roctype, rocDACs, rocPixels)
        no docstring for initDUT, please file a bug report!"""
        cdef char * tbmtype_proxy
        cdef cpp_vector[cpp_vector[cpp_pair[0, 0]]] tbmDACs_proxy
        cdef int itbmDACs
        cdef int tbmDACs_size
        cdef void * tbmDACs_data
        cdef char * roctype_proxy
        cdef cpp_vector[cpp_vector[cpp_pair[0, 0]]] rocDACs_proxy
        cdef int irocDACs
        cdef int rocDACs_size
        cdef void * rocDACs_data
        cdef cpp_vector[cpp_vector[c_api.pixelConfig]] rocPixels_proxy
        cdef int irocPixels
        cdef int rocPixels_size
        cdef cpp_vector[c_api.pixelConfig] * rocPixels_data
        cdef bint rtnval
        tbmtype_bytes = tbmtype.encode()
        # tbmDACs is a ('vector', ('vector', ('pair', 0, 0, 0), 0), 0)
        tbmDACs_size = len(tbmDACs)
        if isinstance(tbmDACs, np.ndarray) and (<np.ndarray> tbmDACs).descr.type_num == np.NPY_OBJECT:
            tbmDACs_data = <void *> np.PyArray_DATA(<np.ndarray> tbmDACs)
            tbmDACs_proxy = cpp_vector[cpp_vector[cpp_pair[0, 0]]](<size_t> tbmDACs_size)
            for itbmDACs in range(tbmDACs_size):
                tbmDACs_proxy[itbmDACs] = tbmDACs_data[itbmDACs]
        else:
            tbmDACs_proxy = cpp_vector[cpp_vector[cpp_pair[0, 0]]](<size_t> tbmDACs_size)
            for itbmDACs in range(tbmDACs_size):
                tbmDACs_proxy[itbmDACs] = <void> tbmDACs[itbmDACs]
        roctype_bytes = roctype.encode()
        # rocDACs is a ('vector', ('vector', ('pair', 0, 0, 0), 0), 0)
        rocDACs_size = len(rocDACs)
        if isinstance(rocDACs, np.ndarray) and (<np.ndarray> rocDACs).descr.type_num == np.NPY_OBJECT:
            rocDACs_data = <void *> np.PyArray_DATA(<np.ndarray> rocDACs)
            rocDACs_proxy = cpp_vector[cpp_vector[cpp_pair[0, 0]]](<size_t> rocDACs_size)
            for irocDACs in range(rocDACs_size):
                rocDACs_proxy[irocDACs] = rocDACs_data[irocDACs]
        else:
            rocDACs_proxy = cpp_vector[cpp_vector[cpp_pair[0, 0]]](<size_t> rocDACs_size)
            for irocDACs in range(rocDACs_size):
                rocDACs_proxy[irocDACs] = <void> rocDACs[irocDACs]
        # rocPixels is a ('vector', ('vector', 'pixelConfig', 0), 0)
        rocPixels_size = len(rocPixels)
        if isinstance(rocPixels, np.ndarray) and (<np.ndarray> rocPixels).descr.type_num == stlcontainers.xd_vector_pixelconfig.num:
            rocPixels_data = <cpp_vector[c_api.pixelConfig] *> np.PyArray_DATA(<np.ndarray> rocPixels)
            rocPixels_proxy = cpp_vector[cpp_vector[c_api.pixelConfig]](<size_t> rocPixels_size)
            for irocPixels in range(rocPixels_size):
                rocPixels_proxy[irocPixels] = rocPixels_data[irocPixels]
        else:
            rocPixels_proxy = cpp_vector[cpp_vector[c_api.pixelConfig]](<size_t> rocPixels_size)
            for irocPixels in range(rocPixels_size):
                rocPixels_proxy[irocPixels] = <cpp_vector[c_api.pixelConfig]> rocPixels[irocPixels]
        rtnval = (<c_api.api *> self._inst).initDUT(std_string(<char *> tbmtype_bytes), tbmDACs_proxy, std_string(<char *> roctype_bytes), rocDACs_proxy, rocPixels_proxy)
        return bool(rtnval)
    
    
    def initTestboard(self, sig_delays, power_settings, pg_setup):
        """initTestboard(self, sig_delays, power_settings, pg_setup)
        no docstring for initTestboard, please file a bug report!"""
        cdef cpp_vector[cpp_pair[0, 0]] sig_delays_proxy
        cdef int isig_delays
        cdef int sig_delays_size
        cdef void * sig_delays_data
        cdef cpp_vector[cpp_pair[0, 0]] power_settings_proxy
        cdef int ipower_settings
        cdef int power_settings_size
        cdef void * power_settings_data
        cdef cpp_vector[cpp_pair[xdress_extra_types.uint16, xdress_extra_types.uchar]] pg_setup_proxy
        cdef int ipg_setup
        cdef int pg_setup_size
        cdef void * pg_setup_data
        cdef bint rtnval
        # sig_delays is a ('vector', ('pair', 0, 0, 0), 0)
        sig_delays_size = len(sig_delays)
        if isinstance(sig_delays, np.ndarray) and (<np.ndarray> sig_delays).descr.type_num == np.NPY_OBJECT:
            sig_delays_data = <void *> np.PyArray_DATA(<np.ndarray> sig_delays)
            sig_delays_proxy = cpp_vector[cpp_pair[0, 0]](<size_t> sig_delays_size)
            for isig_delays in range(sig_delays_size):
                sig_delays_proxy[isig_delays] = sig_delays_data[isig_delays]
        else:
            sig_delays_proxy = cpp_vector[cpp_pair[0, 0]](<size_t> sig_delays_size)
            for isig_delays in range(sig_delays_size):
                sig_delays_proxy[isig_delays] = <void> sig_delays[isig_delays]
        # power_settings is a ('vector', ('pair', 0, 0, 0), 0)
        power_settings_size = len(power_settings)
        if isinstance(power_settings, np.ndarray) and (<np.ndarray> power_settings).descr.type_num == np.NPY_OBJECT:
            power_settings_data = <void *> np.PyArray_DATA(<np.ndarray> power_settings)
            power_settings_proxy = cpp_vector[cpp_pair[0, 0]](<size_t> power_settings_size)
            for ipower_settings in range(power_settings_size):
                power_settings_proxy[ipower_settings] = power_settings_data[ipower_settings]
        else:
            power_settings_proxy = cpp_vector[cpp_pair[0, 0]](<size_t> power_settings_size)
            for ipower_settings in range(power_settings_size):
                power_settings_proxy[ipower_settings] = <void> power_settings[ipower_settings]
        # pg_setup is a ('vector', ('pair', 'uint16', 'uchar', 0), 0)
        pg_setup_size = len(pg_setup)
        if isinstance(pg_setup, np.ndarray) and (<np.ndarray> pg_setup).descr.type_num == np.NPY_OBJECT:
            pg_setup_data = <void *> np.PyArray_DATA(<np.ndarray> pg_setup)
            pg_setup_proxy = cpp_vector[cpp_pair[xdress_extra_types.uint16, xdress_extra_types.uchar]](<size_t> pg_setup_size)
            for ipg_setup in range(pg_setup_size):
                pg_setup_proxy[ipg_setup] = pg_setup_data[ipg_setup]
        else:
            pg_setup_proxy = cpp_vector[cpp_pair[xdress_extra_types.uint16, xdress_extra_types.uchar]](<size_t> pg_setup_size)
            for ipg_setup in range(pg_setup_size):
                pg_setup_proxy[ipg_setup] = <void> pg_setup[ipg_setup]
        rtnval = (<c_api.api *> self._inst).initTestboard(sig_delays_proxy, power_settings_proxy, pg_setup_proxy)
        return bool(rtnval)
    
    
    def programDUT(self):
        """programDUT(self)
        no docstring for programDUT, please file a bug report!"""
        cdef bint rtnval
        rtnval = (<c_api.api *> self._inst).programDUT()
        return bool(rtnval)
    
    
    def _api_setdac_0(self, dacName, dacValue):
        """setDAC(self, dacName, dacValue)
        no docstring for setDAC, please file a bug report!"""
        cdef char * dacName_proxy
        cdef unsigned char dacValue_proxy
        cdef bint rtnval
        dacName_bytes = dacName.encode()
        dacValue_bytes = dacValue.encode()
        rtnval = (<c_api.api *> self._inst).setDAC(std_string(<char *> dacName_bytes), (<unsigned char *> dacValue_bytes)[0])
        return bool(rtnval)
    
    
    def _api_setdac_1(self, dacName, dacValue, rocid):
        """setDAC(self, dacName, dacValue, rocid)
        no docstring for setDAC, please file a bug report!"""
        cdef char * dacName_proxy
        cdef unsigned char dacValue_proxy
        cdef unsigned char rocid_proxy
        cdef bint rtnval
        dacName_bytes = dacName.encode()
        dacValue_bytes = dacValue.encode()
        rocid_bytes = rocid.encode()
        rtnval = (<c_api.api *> self._inst).setDAC(std_string(<char *> dacName_bytes), (<unsigned char *> dacValue_bytes)[0], (<unsigned char *> rocid_bytes)[0])
        return bool(rtnval)
    
    
    _api_setdac_0_argtypes = frozenset(((0, str), (1, str), ("dacName", str), ("dacValue", str)))
    _api_setdac_1_argtypes = frozenset(((0, str), (1, str), (2, str), ("dacName", str), ("dacValue", str), ("rocid", str)))
    
    def setDAC(self, *args, **kwargs):
        """setDAC(self, dacName, dacValue, rocid)
        no docstring for setDAC, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._api_setdac_0_argtypes:
            return self._api_setdac_0(*args, **kwargs)
        if types <= self._api_setdac_1_argtypes:
            return self._api_setdac_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._api_setdac_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._api_setdac_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method setDAC() could not be dispatched')
    
    def _api_settbmreg_0(self, regName, regValue):
        """setTbmReg(self, regName, regValue)
        no docstring for setTbmReg, please file a bug report!"""
        cdef char * regName_proxy
        cdef unsigned char regValue_proxy
        cdef bint rtnval
        regName_bytes = regName.encode()
        regValue_bytes = regValue.encode()
        rtnval = (<c_api.api *> self._inst).setTbmReg(std_string(<char *> regName_bytes), (<unsigned char *> regValue_bytes)[0])
        return bool(rtnval)
    
    
    def _api_settbmreg_1(self, regName, regValue, tbmid):
        """setTbmReg(self, regName, regValue, tbmid)
        no docstring for setTbmReg, please file a bug report!"""
        cdef char * regName_proxy
        cdef unsigned char regValue_proxy
        cdef unsigned char tbmid_proxy
        cdef bint rtnval
        regName_bytes = regName.encode()
        regValue_bytes = regValue.encode()
        tbmid_bytes = tbmid.encode()
        rtnval = (<c_api.api *> self._inst).setTbmReg(std_string(<char *> regName_bytes), (<unsigned char *> regValue_bytes)[0], (<unsigned char *> tbmid_bytes)[0])
        return bool(rtnval)
    
    
    _api_settbmreg_0_argtypes = frozenset(((0, str), (1, str), ("regName", str), ("regValue", str)))
    _api_settbmreg_1_argtypes = frozenset(((0, str), (1, str), (2, str), ("regName", str), ("regValue", str), ("tbmid", str)))
    
    def setTbmReg(self, *args, **kwargs):
        """setTbmReg(self, regName, regValue, tbmid)
        no docstring for setTbmReg, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._api_settbmreg_0_argtypes:
            return self._api_settbmreg_0(*args, **kwargs)
        if types <= self._api_settbmreg_1_argtypes:
            return self._api_settbmreg_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._api_settbmreg_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._api_settbmreg_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method setTbmReg() could not be dispatched')
    
    def status(self):
        """status(self)
        no docstring for status, please file a bug report!"""
        cdef bint rtnval
        rtnval = (<c_api.api *> self._inst).status()
        return bool(rtnval)
    
    
    

    pass





cdef class rocConfig:
    """no docstring for rocConfig, please file a bug report!"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults
        self._dacs = None
        self._pixels = None

    def __init__(self):
        """rocConfig(self)
        """
        self._inst = new c_api.rocConfig()
    
    
    def __dealloc__(self):
        if self._free_inst:
            free(self._inst)

    # attributes
    property dacs:
        """no docstring for dacs, please file a bug report!"""
        def __get__(self):
            cdef stlcontainers._MapUCharUChar dacs_proxy
            if self._dacs is None:
                dacs_proxy = stlcontainers.MapUCharUChar(False, False)
                dacs_proxy.map_ptr = &(<c_api.rocConfig *> self._inst).dacs
                self._dacs = dacs_proxy
            return self._dacs
    
        def __set__(self, value):
            cdef stlcontainers._MapUCharUChar value_proxy
            value_proxy = stlcontainers.MapUCharUChar(value, not isinstance(value, stlcontainers._MapUCharUChar))
            (<c_api.rocConfig *> self._inst).dacs = value_proxy.map_ptr[0]
            self._dacs = None
    
    
    property enable:
        """no docstring for enable, please file a bug report!"""
        def __get__(self):
            return bool((<c_api.rocConfig *> self._inst).enable)
    
        def __set__(self, value):
            (<c_api.rocConfig *> self._inst).enable = <bint> value
    
    
    property pixels:
        """no docstring for pixels, please file a bug report!"""
        def __get__(self):
            cdef np.ndarray pixels_proxy
            cdef np.npy_intp pixels_proxy_shape[1]
            if self._pixels is None:
                pixels_proxy_shape[0] = <np.npy_intp> (<c_api.rocConfig *> self._inst).pixels.size()
                pixels_proxy = np.PyArray_SimpleNewFromData(1, pixels_proxy_shape, stlcontainers.xd_pixelconfig.num, &(<c_api.rocConfig *> self._inst).pixels[0])
                self._pixels = pixels_proxy
            return self._pixels
    
        def __set__(self, value):
            cdef cpp_vector[c_api.pixelConfig] value_proxy
            cdef int ivalue
            cdef int value_size
            cdef c_api.pixelConfig * value_data
            # value is a ('vector', 'pixelConfig', 0)
            value_size = len(value)
            if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == stlcontainers.xd_vector_pixelconfig.num:
                value_data = <c_api.pixelConfig *> np.PyArray_DATA(<np.ndarray> value)
                value_proxy = cpp_vector[c_api.pixelConfig](<size_t> value_size)
                for ivalue in range(value_size):
                    value_proxy[ivalue] = value_data[ivalue]
            else:
                value_proxy = cpp_vector[c_api.pixelConfig](<size_t> value_size)
                for ivalue in range(value_size):
                    value_proxy[ivalue] = (<c_api.pixelConfig *> (<pixelConfig> value[ivalue])._inst)[0]
            (<c_api.rocConfig *> self._inst).pixels = value_proxy
            self._pixels = None
    
    
    property type:
        """no docstring for type, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.rocConfig *> self._inst).type)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.rocConfig *> self._inst).type = (<unsigned char *> value_bytes)[0]
    
    
    # methods
    

    pass





cdef class dut:
    """no docstring for dut, please file a bug report!"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults


    def __init__(self):
        """dut(self)
        """
        self._inst = new c_api.dut()
    
    
    def __dealloc__(self):
        if self._free_inst:
            free(self._inst)

    # attributes

    # methods
    def getAllPixelEnable(self):
        """getAllPixelEnable(self)
        no docstring for getAllPixelEnable, please file a bug report!"""
        cdef bint rtnval
        rtnval = (<c_api.dut *> self._inst).getAllPixelEnable()
        return bool(rtnval)
    
    
    def getDAC(self, rocId, dacName):
        """getDAC(self, rocId, dacName)
        no docstring for getDAC, please file a bug report!"""
        cdef char * dacName_proxy
        cdef xdress_extra_types.uchar rtnval
        dacName_bytes = dacName.encode()
        rtnval = (<c_api.dut *> self._inst).getDAC(<unsigned long long> rocId, std_string(<char *> dacName_bytes))
        return chr(<unsigned int> rtnval)
    
    
    def getDACs(self, rocId):
        """getDACs(self, rocId)
        no docstring for getDACs, please file a bug report!"""
        cdef cpp_vector[cpp_pair[xdress_extra_types.uchar, xdress_extra_types.uchar]] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.dut *> self._inst).getDACs(<unsigned long long> rocId)
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_OBJECT, &rtnval[0])
        return rtnval_proxy
    
    
    def getEnabledPixels(self, rocid):
        """getEnabledPixels(self, rocid)
        no docstring for getEnabledPixels, please file a bug report!"""
        cdef cpp_vector[c_api.pixelConfig] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.dut *> self._inst).getEnabledPixels(<unsigned long long> rocid)
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_pixelconfig.num, &rtnval[0])
        return rtnval_proxy
    
    
    def getEnabledRocs(self):
        """getEnabledRocs(self)
        no docstring for getEnabledRocs, please file a bug report!"""
        cdef cpp_vector[c_api.rocConfig] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.dut *> self._inst).getEnabledRocs()
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_rocconfig.num, &rtnval[0])
        return rtnval_proxy
    
    
    def getEnabledTbms(self):
        """getEnabledTbms(self)
        no docstring for getEnabledTbms, please file a bug report!"""
        cdef cpp_vector[c_api.tbmConfig] rtnval
        cdef np.ndarray rtnval_proxy
        cdef np.npy_intp rtnval_proxy_shape[1]
        rtnval = (<c_api.dut *> self._inst).getEnabledTbms()
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, stlcontainers.xd_tbmconfig.num, &rtnval[0])
        return rtnval_proxy
    
    
    def getModuleEnable(self):
        """getModuleEnable(self)
        no docstring for getModuleEnable, please file a bug report!"""
        cdef bint rtnval
        rtnval = (<c_api.dut *> self._inst).getModuleEnable()
        return bool(rtnval)
    
    
    def getNEnabledPixels(self, rocid):
        """getNEnabledPixels(self, rocid)
        no docstring for getNEnabledPixels, please file a bug report!"""
        cdef unsigned char rocid_proxy
        cdef int rtnval
        rocid_bytes = rocid.encode()
        rtnval = (<c_api.dut *> self._inst).getNEnabledPixels((<unsigned char *> rocid_bytes)[0])
        return int(rtnval)
    
    
    def getNEnabledRocs(self):
        """getNEnabledRocs(self)
        no docstring for getNEnabledRocs, please file a bug report!"""
        cdef int rtnval
        rtnval = (<c_api.dut *> self._inst).getNEnabledRocs()
        return int(rtnval)
    
    
    def getNEnabledTbms(self):
        """getNEnabledTbms(self)
        no docstring for getNEnabledTbms, please file a bug report!"""
        cdef int rtnval
        rtnval = (<c_api.dut *> self._inst).getNEnabledTbms()
        return int(rtnval)
    
    
    def getNMaskedPixels(self, rocid):
        """getNMaskedPixels(self, rocid)
        no docstring for getNMaskedPixels, please file a bug report!"""
        cdef unsigned char rocid_proxy
        cdef int rtnval
        rocid_bytes = rocid.encode()
        rtnval = (<c_api.dut *> self._inst).getNMaskedPixels((<unsigned char *> rocid_bytes)[0])
        return int(rtnval)
    
    
    def getPixelConfig(self, rocid, column, row):
        """getPixelConfig(self, rocid, column, row)
        no docstring for getPixelConfig, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char row_proxy
        cdef c_api.pixelConfig rtnval
        cdef pixelConfig rtnval_proxy
        column_bytes = column.encode()
        row_bytes = row.encode()
        rtnval = (<c_api.dut *> self._inst).getPixelConfig(<unsigned long long> rocid, (<unsigned char *> column_bytes)[0], (<unsigned char *> row_bytes)[0])
        rtnval_proxy = pixelConfig()
        (<c_api.pixelConfig *> rtnval_proxy._inst)[0] = rtnval
        return rtnval_proxy
    
    
    def getPixelEnabled(self, column, row):
        """getPixelEnabled(self, column, row)
        no docstring for getPixelEnabled, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char row_proxy
        cdef bint rtnval
        column_bytes = column.encode()
        row_bytes = row.encode()
        rtnval = (<c_api.dut *> self._inst).getPixelEnabled((<unsigned char *> column_bytes)[0], (<unsigned char *> row_bytes)[0])
        return bool(rtnval)
    
    
    def info(self):
        """info(self)
        no docstring for info, please file a bug report!"""
        (<c_api.dut *> self._inst).info()
    
    
    def _dut_maskallpixels_0(self, mask):
        """maskAllPixels(self, mask)
        no docstring for maskAllPixels, please file a bug report!"""
        (<c_api.dut *> self._inst).maskAllPixels(<bint> mask)
    
    
    def _dut_maskallpixels_1(self, mask, rocid):
        """maskAllPixels(self, mask, rocid)
        no docstring for maskAllPixels, please file a bug report!"""
        cdef unsigned char rocid_proxy
        rocid_bytes = rocid.encode()
        (<c_api.dut *> self._inst).maskAllPixels(<bint> mask, (<unsigned char *> rocid_bytes)[0])
    
    
    _dut_maskallpixels_0_argtypes = frozenset(((0, bool), ("mask", bool)))
    _dut_maskallpixels_1_argtypes = frozenset(((0, bool), (1, str), ("mask", bool), ("rocid", str)))
    
    def maskAllPixels(self, *args, **kwargs):
        """maskAllPixels(self, mask, rocid)
        no docstring for maskAllPixels, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._dut_maskallpixels_0_argtypes:
            return self._dut_maskallpixels_0(*args, **kwargs)
        if types <= self._dut_maskallpixels_1_argtypes:
            return self._dut_maskallpixels_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._dut_maskallpixels_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._dut_maskallpixels_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method maskAllPixels() could not be dispatched')
    
    def _dut_maskcolumn_0(self, column, mask):
        """maskColumn(self, column, mask)
        no docstring for maskColumn, please file a bug report!"""
        cdef unsigned char column_proxy
        column_bytes = column.encode()
        (<c_api.dut *> self._inst).maskColumn((<unsigned char *> column_bytes)[0], <bint> mask)
    
    
    def _dut_maskcolumn_1(self, column, mask, rocid):
        """maskColumn(self, column, mask, rocid)
        no docstring for maskColumn, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char rocid_proxy
        column_bytes = column.encode()
        rocid_bytes = rocid.encode()
        (<c_api.dut *> self._inst).maskColumn((<unsigned char *> column_bytes)[0], <bint> mask, (<unsigned char *> rocid_bytes)[0])
    
    
    _dut_maskcolumn_0_argtypes = frozenset(((0, str), (1, bool), ("column", str), ("mask", bool)))
    _dut_maskcolumn_1_argtypes = frozenset(((0, str), (1, bool), (2, str), ("column", str), ("mask", bool), ("rocid", str)))
    
    def maskColumn(self, *args, **kwargs):
        """maskColumn(self, column, mask, rocid)
        no docstring for maskColumn, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._dut_maskcolumn_0_argtypes:
            return self._dut_maskcolumn_0(*args, **kwargs)
        if types <= self._dut_maskcolumn_1_argtypes:
            return self._dut_maskcolumn_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._dut_maskcolumn_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._dut_maskcolumn_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method maskColumn() could not be dispatched')
    
    def _dut_maskpixel_0(self, column, row, mask):
        """maskPixel(self, column, row, mask)
        no docstring for maskPixel, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char row_proxy
        column_bytes = column.encode()
        row_bytes = row.encode()
        (<c_api.dut *> self._inst).maskPixel((<unsigned char *> column_bytes)[0], (<unsigned char *> row_bytes)[0], <bint> mask)
    
    
    def _dut_maskpixel_1(self, column, row, mask, rocid):
        """maskPixel(self, column, row, mask, rocid)
        no docstring for maskPixel, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char row_proxy
        cdef unsigned char rocid_proxy
        column_bytes = column.encode()
        row_bytes = row.encode()
        rocid_bytes = rocid.encode()
        (<c_api.dut *> self._inst).maskPixel((<unsigned char *> column_bytes)[0], (<unsigned char *> row_bytes)[0], <bint> mask, (<unsigned char *> rocid_bytes)[0])
    
    
    _dut_maskpixel_0_argtypes = frozenset(((0, str), (1, str), (2, bool), ("column", str), ("row", str), ("mask", bool)))
    _dut_maskpixel_1_argtypes = frozenset(((0, str), (1, str), (2, bool), (3, str), ("column", str), ("row", str), ("mask", bool), ("rocid", str)))
    
    def maskPixel(self, *args, **kwargs):
        """maskPixel(self, column, row, mask, rocid)
        no docstring for maskPixel, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._dut_maskpixel_0_argtypes:
            return self._dut_maskpixel_0(*args, **kwargs)
        if types <= self._dut_maskpixel_1_argtypes:
            return self._dut_maskpixel_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._dut_maskpixel_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._dut_maskpixel_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method maskPixel() could not be dispatched')
    
    def printDACs(self, rocId):
        """printDACs(self, rocId)
        no docstring for printDACs, please file a bug report!"""
        (<c_api.dut *> self._inst).printDACs(<unsigned long long> rocId)
    
    
    def setROCEnable(self, rocId, enable):
        """setROCEnable(self, rocId, enable)
        no docstring for setROCEnable, please file a bug report!"""
        (<c_api.dut *> self._inst).setROCEnable(<unsigned long long> rocId, <bint> enable)
    
    
    def setTBMEnable(self, tbmId, enable):
        """setTBMEnable(self, tbmId, enable)
        no docstring for setTBMEnable, please file a bug report!"""
        (<c_api.dut *> self._inst).setTBMEnable(<unsigned long long> tbmId, <bint> enable)
    
    
    def status(self):
        """status(self)
        no docstring for status, please file a bug report!"""
        cdef bint rtnval
        rtnval = (<c_api.dut *> self._inst).status()
        return bool(rtnval)
    
    
    def _dut_testallpixels_0(self, enable):
        """testAllPixels(self, enable)
        no docstring for testAllPixels, please file a bug report!"""
        (<c_api.dut *> self._inst).testAllPixels(<bint> enable)
    
    
    def _dut_testallpixels_1(self, enable, rocid):
        """testAllPixels(self, enable, rocid)
        no docstring for testAllPixels, please file a bug report!"""
        cdef unsigned char rocid_proxy
        rocid_bytes = rocid.encode()
        (<c_api.dut *> self._inst).testAllPixels(<bint> enable, (<unsigned char *> rocid_bytes)[0])
    
    
    _dut_testallpixels_0_argtypes = frozenset(((0, bool), ("enable", bool)))
    _dut_testallpixels_1_argtypes = frozenset(((0, bool), (1, str), ("enable", bool), ("rocid", str)))
    
    def testAllPixels(self, *args, **kwargs):
        """testAllPixels(self, enable, rocid)
        no docstring for testAllPixels, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._dut_testallpixels_0_argtypes:
            return self._dut_testallpixels_0(*args, **kwargs)
        if types <= self._dut_testallpixels_1_argtypes:
            return self._dut_testallpixels_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._dut_testallpixels_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._dut_testallpixels_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method testAllPixels() could not be dispatched')
    
    def _dut_testpixel_0(self, column, row, enable):
        """testPixel(self, column, row, enable)
        no docstring for testPixel, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char row_proxy
        column_bytes = column.encode()
        row_bytes = row.encode()
        (<c_api.dut *> self._inst).testPixel((<unsigned char *> column_bytes)[0], (<unsigned char *> row_bytes)[0], <bint> enable)
    
    
    def _dut_testpixel_1(self, column, row, enable, rocid):
        """testPixel(self, column, row, enable, rocid)
        no docstring for testPixel, please file a bug report!"""
        cdef unsigned char column_proxy
        cdef unsigned char row_proxy
        cdef unsigned char rocid_proxy
        column_bytes = column.encode()
        row_bytes = row.encode()
        rocid_bytes = rocid.encode()
        (<c_api.dut *> self._inst).testPixel((<unsigned char *> column_bytes)[0], (<unsigned char *> row_bytes)[0], <bint> enable, (<unsigned char *> rocid_bytes)[0])
    
    
    _dut_testpixel_0_argtypes = frozenset(((0, str), (1, str), (2, bool), ("column", str), ("row", str), ("enable", bool)))
    _dut_testpixel_1_argtypes = frozenset(((0, str), (1, str), (2, bool), (3, str), ("column", str), ("row", str), ("enable", bool), ("rocid", str)))
    
    def testPixel(self, *args, **kwargs):
        """testPixel(self, column, row, enable, rocid)
        no docstring for testPixel, please file a bug report!"""
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._dut_testpixel_0_argtypes:
            return self._dut_testpixel_0(*args, **kwargs)
        if types <= self._dut_testpixel_1_argtypes:
            return self._dut_testpixel_1(*args, **kwargs)
        # duck-typed dispatch based on whatever works!
        try:
            return self._dut_testpixel_0(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            return self._dut_testpixel_1(*args, **kwargs)
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method testPixel() could not be dispatched')
    
    

    pass





cdef class pixel:
    """no docstring for pixel, please file a bug report!"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults


    def _pixel_pixel_0(self):
        """pixel(self)
        """
        self._inst = new c_api.pixel()
    
    
    def _pixel_pixel_1(self, address, data):
        """pixel(self, address, data)
        """
        self._inst = new c_api.pixel(<int> address, <int> data)
    
    
    _pixel_pixel_0_argtypes = frozenset()
    _pixel_pixel_1_argtypes = frozenset(((0, int), (1, int), ("address", int), ("data", int)))
    
    def __init__(self, *args, **kwargs):
        """pixel(self, address, data)
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._pixel_pixel_0_argtypes:
            self._pixel_pixel_0(*args, **kwargs)
            return
        if types <= self._pixel_pixel_1_argtypes:
            self._pixel_pixel_1(*args, **kwargs)
            return
        # duck-typed dispatch based on whatever works!
        try:
            self._pixel_pixel_0(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._pixel_pixel_1(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method __init__() could not be dispatched')
    
    def __dealloc__(self):
        if self._free_inst:
            free(self._inst)

    # attributes
    property column:
        """no docstring for column, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.pixel *> self._inst).column)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.pixel *> self._inst).column = (<unsigned char *> value_bytes)[0]
    
    
    property roc_id:
        """no docstring for roc_id, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.pixel *> self._inst).roc_id)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.pixel *> self._inst).roc_id = (<unsigned char *> value_bytes)[0]
    
    
    property row:
        """no docstring for row, please file a bug report!"""
        def __get__(self):
            return chr(<unsigned int> (<c_api.pixel *> self._inst).row)
    
        def __set__(self, value):
            cdef unsigned char value_proxy
            value_bytes = value.encode()
            (<c_api.pixel *> self._inst).row = (<unsigned char *> value_bytes)[0]
    
    
    property value:
        """no docstring for value, please file a bug report!"""
        def __get__(self):
            return int((<c_api.pixel *> self._inst).value)
    
        def __set__(self, value):
            (<c_api.pixel *> self._inst).value = <int> value
    
    
    # methods
    def decode(self, address):
        """decode(self, address)
        no docstring for decode, please file a bug report!"""
        (<c_api.pixel *> self._inst).decode(<int> address)
    
    
    

    pass







